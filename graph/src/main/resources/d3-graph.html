<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<title>Gradle Task Graph</title>
	<link rel="stylesheet" href="d3-graph.css" />
	<!-- src==xlink:href in svg-->
	<script src="d3.js" charset="utf-8"></script>
	<script src="d3-graph.phys.js"></script>
</head>
<body onload="main()">
	<svg xmlns="http://www.w3.org/2000/svg" pointer-events="all">
		<defs>
			<radialGradient id="background-gradient" cx="70%" cy="100%" r="90%" fy="60%">
				<stop offset="5%" stop-color="#EEFFFF" />
				<stop offset="95%" stop-color="#DDEEFF" />
			</radialGradient>
			<filter id="negative">
				<feColorMatrix in="SourceGraphic" type="matrix" values="
					-1 0 0 0 1
					0 -1 0 0 1
					0 0 -1 0 1
					0 0 0 1 0
				" />
			</filter>
			<marker id="arrow-out" viewBox="0,0 10 10" refX="8" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto">
				<path d="M 0 0 L 10 5 L 0 10 z" />
			</marker>
			<marker id="arrow-in" viewBox="0,0 10 10" refX="2" refY="5" markerUnits="strokeWidth" markerWidth="8" markerHeight="6" orient="auto">
				<path d="M 10 0 L 0 5 L 10 10 z" />
			</marker>
		</defs>
		<rect id="background" width="100%" height="100%" fill="url(#background-gradient)" pointer-events="all" />
		<g id="root">
			<g id="nodes"></g>
			<g id="links"></g>
		</g>
		<g id="legend" transform="translate(80, 50)" style="visibility: hidden;">
			<!--suppress RequiredAttributes width/height will be set in autoSizeLegend() -->
			<rect id="legend-bg" />
			<text id="legend-header">Legend</text>
		</g>
		<!--<circle id="cursor" r="20" transform="translate(-100, -100)" />-->
	</svg>
	<div id="details" style="visibility: hidden;">
		<div id="detail-running" class="loader"></div>
		<div id="detail-name"></div>
		<div id="detail-project"></div>
		<div id="detail-type"></div>
		<div id="detail-state"></div>
		<div id="detail-pos"></div>
		<ul id="detail-depends"></ul>
		<ul id="detail-dependents"></ul>
	</div>
	<div id="menu">
		<button onclick="force.stop()">Freeze</button>
		<button onclick="force.restart()">Thaw</button>
		<button onclick="force.stop(); zoomFit(0.95, 500)">Fit</button>
	</div>
	<script>//<![CDATA[
'use strict';
function main() {
	// needs extra dispatch because LoadWorker.SUCCEEDED is after window.onload
	setTimeout(function startUp() {
		console.debug("Startup " + navigator.userAgent);
		resize();
		details.init();
		if (window['java'] !== undefined) {
			console.debug("We're in JavaFX");
		} else {
			demo();
			console.debug("We're in a browser");
		}
	}, 0);
}

const zoom = d3
	.zoom()
	.scaleExtent([ 1 / 4, 4 ])
	.on('zoom', function svgZoom(event) {
		const transform = event.transform;
		console.debug("zoom", transform);
		root.attr('transform',
			'translate(' + transform.x + ',' + transform.y + ')'
			+   'scale(' + transform.k + ')');
	})
;

const svg = d3
	.select('svg')
	.call(zoom)
	//.on('mousemove', function svgMouseMove(event) {
	//	cursor.attr('transform', 'translate(' + d3.pointer(event) + ')');
	//})
;

let demoIdCounter = 0;
svg.select('#background')
	.on('click', function backgroundClick() {
		selectNode(null);
	})
	.on('mousedown', function backgroundMouseDown(event) {
		if (event.button !== 1) {
			return;
		}
		event.preventDefault();
		const point = d3.pointer(node_group.node());
		model.add({
			id: '____' + demoIdCounter++ + '____',
			type: 'unknown',
			x: point[0],
			y: point[1],
		});
		/*
		// Add links to any nearby nodes.
		nodes.forEach(target => {
			const x = target.x - node.x,
			      y = target.y - node.y;
			if (Math.sqrt(x * x + y * y) < 30) {
				links.push({ source: node, target: target });
			}
		});
		*/
	})
;
//const cursor = svg.select('#cursor');
const root = svg.select('#root');
const node_group = svg.select('#nodes');
const link_group = svg.select('#links');

const force = d3
	.forceSimulation()
	.force("size", d3.forceCenter().strength(0.03)) 
	.force("link", d3.forceLink().strength(0.3))
	.force("charge", d3.forceManyBody().strength(-400))
	.on('tick', function forceTick() {
		//const q = d3.geom.quadtree(nodes);
		//node.each(function(n) { q.visit(phys.collide(n)) });
		uiLinks
			.attr('x1', d => phys.pointOnRect(d.source, d.target).x)
			.attr('y1', d => phys.pointOnRect(d.source, d.target).y)
			.attr('x2', d => phys.pointOnRect(d.target, d.source).x)
			.attr('y2', d => phys.pointOnRect(d.target, d.source).y)
		;

		uiNodes
			.attr('transform', d => 'translate(' + d.x + ',' + d.y + ')')
		;

		details.refreshDisplay();
		//zoomFit();
	})
;

const details = function Details() {
	const det = d3.select('#details');
	const progressUI = det.select('#detail-running');
	const nameUI = det.select('#detail-name').insert('span');
	const projectUI = det.select('#detail-project');
	const typeUI = det.select('#detail-type');
	const stateUI = det.select('#detail-state');
	const posUI = det.select('#detail-pos');
	const dependsUI = det.select('#detail-depends');
	const dependentsUI = det.select('#detail-dependents');
	// Workaround for: https://github.com/mbostock/d3/issues/94,
	// keep reference to #text and update it later, dependsUI.text("") would clear <li>s too
	const dependsUILabel = d3.select(document.createTextNode(""));
	dependsUI.node().appendChild(dependsUILabel.node());
	const dependentsUILabel = d3.select(document.createTextNode(""));
	dependentsUI.node().appendChild(dependentsUILabel.node());

	nameUI.on('click', function nameUIClick() {
		det.classed('collapsed', !det.classed('collapsed'));
	});
	let currentNode = null;
	let currentNodeIsLocked = false;
	let currentNodeIsActive = false;


	function bindDeps(/* d3.selection<ul> */ ui, label, /* Array<String> */ deps) {
		const dependsData = ui.selectAll('li').data(deps, d => d);
		dependsData.exit().remove();

		dependsData.enter()
			.append('li')
			.text(d => d)
			.on('click', function detailsDependencyClick(event, d) {
				selectNode(graph[d]);
			})
		;
		label.text(deps.length === 0? "nothing" : "");
	}

	function display(d) {
		if (currentNode && !d && stateUI.text() === 'executing') {
			display(currentNode);
			return;
		}

		det.style('visibility', d? 'visible' : 'hidden');

		if (d) {
			nameUI.text(d.ui.label());
			autoSizeText(nameUI.node());
			projectUI.text(d.ui.project() || "root project");
			typeUI.text(d.type || 'normal');
			stateUI.text(d.state || 'scheduled');
			progressUI.style('display', d.state === 'executing'? 'block' : 'none');
			posUI.text(d.x.toFixed(2) + ", " + d.y.toFixed(2));

			bindDeps(dependsUI, dependsUILabel, d.deps);
			bindDeps(dependentsUI, dependentsUILabel, d.depsInverse);
		}

		currentNode = d;
	}

	function autoPick() {
		const executing = node.filter('.executing');
		return executing.size() === 0? null : executing.datum();
	}

	return {
		init() {
			display(null);
		},
		showNode(d) {
			if (!currentNodeIsLocked) {
				currentNodeIsActive = true;
				display(d);
			}
		},
		hideNode(/*d*/) {
			currentNodeIsActive = false;
			this.refreshDisplay();
		},
		lockNode(d) {
			if (d) {
				currentNodeIsLocked = true;
				display(d);
			} else {
				currentNodeIsLocked = false;
				display(autoPick());
			}
		},
		refreshDisplay() {
			if (!currentNodeIsLocked && !currentNodeIsActive) {
				display(autoPick());
			} else {
				display(currentNode);
			}
		},
	};
}();

// noinspection ES6ConvertVarToLetConst
var graph = {}; // window.graph is referenced as such.
const nodes = force.nodes();
const links = force.force("link").links();
let node = node_group.selectAll('.node');
let link = link_group.selectAll('.link');
let uiNodes = link, uiLinks = node;

d3.select(window).on('resize', resize);

function resize() {
	const centerX = window.innerWidth / 2, centerY = window.innerHeight / 2;
	const size = force.force('size');
	console.debug("Resize center", [ size.x(), size.y() ], [ centerX, centerY ]);
	//zoom.center([ centerX, centerY ]);
	size.x(centerX).y(centerY);
	force.restart();
}

function restart() {
	link = link.data(links, d => d.linkId());
	link.exit().remove();
	uiLinks = link
		.enter()
		.append('line')
		.each(function storeUiLink(d) { d.ui.edge = this; })
		.attr('id', d => d.linkId())
		.attr('class', 'link')
		.style('marker-start', 'url(#arrow-in)')
		//.style('marker-end', 'url(#arrow-out)')
	;

	node = node.data(nodes, d => d.ui.nodeId());
	node.exit().remove();

	uiNodes = createNodes(node);
	uiNodes
		.on('click', function nodeClick(event, d) {
			selectNode(d);
		})
		.on('mousedown', function nodeMouseDown(event, d) {
			details.lockNode(d);
		})
		.on('mouseup', function nodeMouseUp(/*event, d*/) {
			details.lockNode(null);
		})
		.on('mouseover', function nodeMouseOver(event, d) {
			details.showNode(d);
		})
		.on('mouseout', function nodeMouseOut(event, d) {
			details.hideNode(d);
		})
		.call(d3
			.drag()
			.on("start", function dragStart(event, d) {
				if (!event.active) {
					force.alphaTarget(0.3).restart();
				}
				d.fx = d.x;
				d.fy = d.y;
			})
			.on("drag", function dragMove(event, d) {
				d.fx = event.x;
				d.fy = event.y;
			})
			.on("end", function dragEnd(event, d) {
				if (!event.active) {
					force.alphaTarget(0);
				}
				d.fx = null;
				d.fy = null;
			})
		)
	;
	force.stop();
	force.nodes(nodes);
	force.force("link").links(links);
	force.restart();
}

function selectNode(d) { // TODO use #task-id for back navigation support
	uiNodes.filter('.selected').classed('selected', false);
	if (d) {
		d3.select(d.ui.node).classed('selected', true);
	}
	details.lockNode(d);
}

/**
 * @param paddingPercent 0.0 to 1.0, recommended close to 1.0
 * @param transitionDuration milliseconds, positive, can be 0
 */
function zoomFit(paddingPercent, transitionDuration) {
	const bounds = root.node().getBBox();
	const parent = root.node().parentElement;
	const fullWidth  = parent.clientWidth,
	      fullHeight = parent.clientHeight;
	const width  = bounds.width,
	      height = bounds.height;
	const midX = bounds.x + width / 2,
	      midY = bounds.y + height / 2;
	if (width === 0 || height === 0) {
		return; // Nothing to fit.
	}
	const scale = paddingPercent / Math.max(width / fullWidth, height / fullHeight);
	const translate = [ fullWidth / 2 - scale * midX, fullHeight / 2 - scale * midY ];

	console.debug("zoomFit", translate, scale);
	svg
		.transition()
		.duration(transitionDuration)
		.call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
}

const legendData = [
	{ classes: '', title: "task" },
	{ classes: 'success', title: "Success" },
	{ classes: 'uptodate', title: "UP-TO-DATE" },
	{ classes: 'failure', title: "FAILED" },
	{ classes: 'skipped', title: "SKIPPED" },
	{ classes: 'executing', title: "Executing..." },
	{ classes: 'requested', title: "Requested" },
	{ classes: 'excluded', title: "--exclude-task" },
	{ classes: 'nowork', title: "No Work" },
	{ classes: 'unknown', title: "Unknown" },
	{ classes: 'selected', title: "Selected" },
];
!function buildLegend(legendData) {
	for (const i in legendData) {
		const legendDatum = legendData[i];
		// TODO use nodify?
		legendDatum.ui = {
			data: legendDatum,
			project() { return ":sub:module"; },
			label() { return this.data.title; },
			nodeId() { return 'legend_' + this.data.id; },
		};
		legendDatum.deps = [];
		legendDatum.depsInverse = [];
		legendDatum.id = legendData[i].classes.replace(/ /, '-');
	}
	const legend = svg
		.select('#legend');
	let legendNodes = legend
		.selectAll('.node')
		.data(legendData, d => d.ui.nodeId())
	;
	const legendHeader = legend
		.select('#legend-header')
		.on('click', function legendHeaderClick() {
			legend.classed('collapsed', !legend.classed('collapsed'));
			autoSizeLegend();
		})
	;
	const headerHeight = legendHeader.node().getBBox().height;
	// noinspection JSUnusedAssignment
	legendNodes = createNodes(legendNodes)
		.attr('class', d => 'node ' + d.classes)
		.attr('transform', (d, i) => 'translate(0,' + (headerHeight + 10 + i * d.height * 1.3) + ')')
	;

	const legendBackground = legend
		.select('#legend-bg')
		.on('click', function legendBackgroundClick() {
			legend.classed('collapsed', !legend.classed('collapsed'));
			autoSizeLegend();
		})
	;

	function autoSizeLegend() {
		legendBackground.style('display', 'none');
		const legendBox = legend.node().getBBox();
		const legendPadding = 16;
		legendBackground
			.attr("x", legendBox.x - legendPadding)
			.attr("y", legendBox.y - legendPadding)
			.attr("width", legendBox.width + 2 * legendPadding)
			.attr("height", legendBox.height + 2 * legendPadding)
		;
		legendBackground.style('display', 'block');
	}

	autoSizeLegend();
	legend.style('visibility', 'visible');
}(legendData);

function nodeClasses(d) {
	return 'node'
		 + (d.type? ' ' + d.type : '')
		 + (d.state? ' ' + d.state : '')
		 + (d.deps.length === 0? ' leaf' : '')
		 + (d.deps.length === 1 && d.depsInverse.length === 1? ' straight' : '')
	;
}

function createNodes(nodeData) {
	const uiNodes = nodeData
		.enter()
		.append('g')
		.each(function storeUiNode(d) { d.ui.node = this; })
		.attr('id', d => d.ui.nodeId())
	;
	uiNodes
		.attr("class", nodeClasses)
	;
	const rect = uiNodes.append('rect')
		.each(function storeUiNodeBackground(d) { d.ui.bg = this; })
	;
	//noinspection JSUnusedLocalSymbols
	const text = uiNodes.append('text')
		.each(function storeUiNodeText(d) { d.ui.text = this; })
		.classed('label', true)
		.text(d => d.ui.label())
	;
	//uiNodes.append('circle').attr("cx", 0).attr("cy", 0).attr("r", 3).attr("fill", "red");
	const padding = { x: 5, y: 4 };

	rect
		.attr('width', d => d.ui.text.getBBox().width + 2.0 * padding.x)
		.attr('height', d => d.ui.text.getBBox().height + 2.0 * padding.y)
		.attr('x', d => +d3.select(d.ui.bg).attr('width') / -2.0)
		.attr('y', d => +d3.select(d.ui.bg).attr('height') / -2.0)
	;

	uiNodes.append('text')
		.classed('project', true)
		.text(d => d.ui.project())
		.attr('x', d => +d3.select(d.ui.bg).attr('x') + +d3.select(d.ui.bg).attr('width') - padding.x)
		.attr('y', d => +d3.select(d.ui.bg).attr('y') - 1)
	;

	uiNodes.each(function resizeUiNode(d) {
		const box = d.ui.node.getBBox();
		d.width = box.width;
		d.height = box.height;
	});
	return uiNodes;
}

let model = function Model() {
	return {
		init(graph) {
			function filter(d) { return d.type === 'unknown'; }

			if (typeof graph === 'string') {
				graph = JSON.parse(graph);
			}
			window.graph = graph;

			nodes.length = 0;
			for (const dataIndex in graph) {
				const data = graph[dataIndex];
				if (filter(data)) {
					continue;
				}
				const node = nodify(dataIndex, data);
				nodes.push(node);
			}
			links.length = 0;
			for (const nodeIndex in graph) {
				const fromNode = graph[nodeIndex];
				if (filter(fromNode)) {
					continue;
				}
				for (const depIndex in fromNode.deps) {
					const toNode = graph[fromNode.deps[depIndex]];
					if (filter(toNode)) {
						continue;
					}
					toNode.depsInverse.push(fromNode.id);
					const link = createLink(fromNode, toNode);
					links.push(link);
					fromNode.links.push(link);
				}
			}
			restart();
			// force.tick(10);
			// setTimeout is required to allow the browser to render the nodes.
			setTimeout(function initFirstZoomFit() { zoomFit(0.95, 100); }, 1000);
			setTimeout(function initSecondZoomFit() { zoomFit(0.95, 100); }, 2000);
		},
		update(task, result) {
			const node = d3.select('#' + constructNodeId(task));
			const data = node.datum();
			data.state = result;
			node.attr('class', nodeClasses(data));
			details.refreshDisplay();
		},
		add(data) {
			// STOPSHIP middle click weird, probably due to selection changes in v4, restart() needs to be rewritten.
			nodes.push(nodify(data.id, data));
			restart();
		},
	};

	function cleanName(name) {
		return name.replace(/:/g, '-');
	}

	function constructNodeId(name) {
		return 'node_' + cleanName(name);
	}

	function constructLinkId(from, to) {
		return 'link_' + cleanName(from) + '_' + cleanName(to);
	}

	function nodify(id, node) {
		const defaults = {
			id: id,
			deps: [],
			depsInverse: [],
		};
		const viewModel = {
			links: [],
			ui: {
				data: node,
				node: null,
				text: null,
				bg: null,
				project() {
					const label = this.data.label || this.data.id;
					return label.replace(/^:?(.+):.+$|.*/, '$1');
				},
				label() {
					const label = this.data.label || this.data.id;
					return label.replace(/^:?(.*):/, '');
				},
				nodeId() {
					return constructNodeId(this.data.id);
				},
			},
			x2() {
				return this.x + this.width;
			},
			y2() {
				return this.y + this.height;
			},
		};

		node.toString = function() {
			return this.id + " @ " + this.x + "," + this.y + " " + this.width + "x" + this.height;
		};

		for (const i in defaults) {
			if (node[i] === undefined) {
				node[i] = defaults[i];
			}
		}
		for (const i in viewModel) {
			if (node[i] === undefined) {
				node[i] = viewModel[i];
			} else {
				console.error("Property " + i + " already exists", node, viewModel);
			}
		}
		return node; // == $.merge(node, defaults, viewModel);
	}

	function createLink(fromNode, toNode) {
		return {
			source: fromNode,
			target: toNode,
			weight: 1,
			ui: {
				edge: null,
			},
			linkId() {
				return constructLinkId(this.source.id, this.target.id);
			},
			toString() {
				return this.source + " -> " + this.target;
			},
		};
	}
}();
//noinspection JSUnresolvedReference
if (window.java) {
	model = function javafy(model) {
		function javaEntry(name, fun) {
			return function() {
				console.trace(name + "(" + JSON.stringify(arguments) + ")");
				try {
					return fun.apply(this, arguments);
				} catch (e) {
					console.warn(e.name + ": " + e.message + " " + e.stack);
				}
			};
		}

		for (const item in model) {
			if (typeof model[item] === 'function') {
				model[item] = javaEntry(item, model[item]);
			}
		}
		return model;
	}(model);
}


function autoSizeText(elem, min, max, step, lastChange) {
	min = min || 1;
	max = max || Infinity;
	step = step || 1;
	lastChange = lastChange !== undefined? lastChange : 0;

	function px(pixelStyle) {
		return +pixelStyle.slice(0, -2);
	}

	const elemBounds  = elem.getBoundingClientRect(),
	      style       = window.getComputedStyle(elem),
	      parentStyle = window.getComputedStyle(elem.parentNode)
	;
	const elemSize = { width: elemBounds.width, height: elemBounds.height };
	const parentSize = { width: px(parentStyle.width), height: px(parentStyle.height) };
	let fontSize = px(style.fontSize);

	//console.debug("autoSizeText(" + elem.textContent + ", " + min + ", " + max + ")", fontSize, elemSize, parentSize);
	let change = 0, stop = false;
	const needsSmaller = elemSize.width > parentSize.width || elemSize.height > parentSize.height;
	const needsBigger = elemSize.width < parentSize.width && elemSize.height < parentSize.height;
	const lastSmaller = lastChange <= 0;
	const lastBigger = lastChange >= 0;
	if (lastSmaller && needsSmaller) { //console.debug('lastSmaller needsSmaller')
		change = -step; // continue shrinking
	} else if (lastBigger && needsBigger) { //console.debug('lastBigger needsBigger')
		change = +step; // continue growing
	} else if (lastSmaller && needsBigger) { //console.debug('lastSmaller needsBigger')
		change = 0; // found the smallest fit
	} else if (lastBigger && needsSmaller) { //console.debug('lastBigger needsSmaller')
		change = -lastChange; // just overstepped the limit, backtrack once
		stop = true;
	} else if (!needsBigger && !needsSmaller) { //console.debug("just right");
		change = 0; // doesn't need to be any different
	} else {
		throw "Invalid state"
			+ ": lastSmaller=" + lastSmaller
			+ ", lastBigger=" + lastBigger
			+ ", needsSmaller=" + needsSmaller
			+ ", needsBigger=" + needsBigger
		;
	}

	if (change !== 0) {
		fontSize += change;
		if (min <= fontSize && fontSize <= max) {
			elem.style.setProperty('font-size', fontSize + 'px');
		}
	} else {
		stop = true;
	}
	if (!stop) {
		autoSizeText(elem, min, max, step, change);
	}
}

function demo() {
	const allDeps = {
		":onlyIf": { deps: [] },
		":sub:proj:throwTask": { state: 'failure', deps: [] },
		preBuild: { state: 'skipped', deps: [ ":onlyIf", ":sub:proj:throwTask" ] },
		preDebugBuild: { state: 'success', deps: [ "preBuild" ] },
		checkDebugManifest: { state: 'uptodate', deps: [ "preDebugBuild" ] },
		prepareDebugDependencies: { state: 'success', deps: [ /*"preDebugBuild",*/ "checkDebugManifest" ] },
		compileDebugAidl: { deps: [ "prepareDebugDependencies" ] },
		compileDebugRenderscript: { deps: [ "prepareDebugDependencies"/*, "checkDebugManifest"*/ ] },
		generateDebugBuildConfig: { deps: [ "checkDebugManifest" ] },
		generateDebugAssets: { deps: [] },
		mergeDebugAssets: { deps: [ "prepareDebugDependencies", "generateDebugAssets" ] },
		generateDebugResValues: { deps: [] },
		generateDebugResources: { deps: [ "generateDebugResValues", "compileDebugRenderscript" ] },
		mergeDebugResources: { deps: [ "generateDebugResources" ] },
		processDebugManifest: { deps: [ "prepareDebugDependencies" ] },
		processDebugResources: { deps: [ "mergeDebugAssets", "mergeDebugResources", "processDebugManifest" ] },
		generateDebugSources: { deps: [ /*"compileDebugRenderscript",*/ "compileDebugAidl", "processDebugResources", "generateDebugBuildConfig" ] },
		processDebugJavaRes: { deps: [] },
		compileDebugJava: { state: 'nowork', deps: [ /*"prepareDebugDependencies",*/ "processDebugJavaRes", "generateDebugSources", "_debugCompile" ] },
		compileDebugNdk: { type: 'excluded', deps: [ "preDebugBuild" ] },
		compileDebugSources: { deps: [ "compileDebugJava", "compileDebugNdk" ] },
		preDexDebug: { deps: [ "_debugApk" ] },
		dexDebug: { deps: [ "compileDebugJava", "preDexDebug" ] },
		validateDebugSigning: { deps: [] },
		packageDebug: { deps: [ /*"compileDebugJava",*/ "validateDebugSigning", /*"processDebugJavaRes",*/ "dexDebug", /*"processDebugResources",*/ "compileDebugNdk" ] },
		zipalignDebug: { deps: [ "packageDebug" ] },
		assembleDebug: { type: 'requested', deps: [ "zipalignDebug", "compileDebugSources" ] },
		assembleRelease: { type: 'requested', deps: [] },
		":lib:assemble": { type: 'requested', deps: [ "assembleRelease", "assembleDebug" ] },
		_debugApk: { type: 'unknown', deps: [] },
		_debugCompile: { type: 'unknown', deps: [] },
	};

	model.init(allDeps);
	setTimeout(function demoDelayedEffects() {
		model.update("generateDebugResValues", 'success');
		model.update("generateDebugBuildConfig", 'executing');
	}, 1000);
}

//]]></script>
</body>
</html>
